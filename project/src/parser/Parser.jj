options {
  STATIC=false;
}

PARSER_BEGIN(Parser)

package parser;
import ast.*;

public class Parser {

}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
}
TOKEN : /* OPERATORS */
{
  < Num: (["0"-"9"]) + >
| < PLUS : "+" >
| < TIMES : "*" >
| < MINUS : "-">
| < NEG : "~">
| < GT: ">" >
| < LT: "<" >
| < GTOEQ: ">=" >
| < LTOEQ: "<=" >
| < DER: "!">
| < DIV : "/">
| < LPAR : "(" >
| < RPAR : ")" >
| < TRUE : "true" >
| < FALSE : "false" >
| < EQ : "=" >
| < NEQ : "!=" >
| < AND : "&&" >
| < OR : "||" >
| < IFQ : "?" >
| < COLON : ":" >
| < EOL: "\n" >
| < LET: "let" >
| < IN: "in" >
}

TOKEN :
{
  < INT : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
| < ID : (< LETTER >)+ >
| < #LETTER : [ "a"-"z", "A"-"Z" ] >
}

Exp Start() :
{ Exp e; }
{
   e = logic() <EOL>  { return e; }
}


Exp logic():
{ Exp e1,e2; }
{
 e1 = eqOp() ( <AND> e2=eqOp() { e1 = new ASTAnd(e1,e2); }
                | <OR> e2=eqOp() { e1 = new ASTOr(e1,e2); } )*
  { return e1; }
}

Exp eqOp():
{ Exp e1,e2; }
{
 e1 = boolOp() ( <EQ> e2=boolOp() { e1 = new ASTEq(e1,e2); }
                | <NEQ> e2=boolOp() {e1 = new ASTNEq(e1, e2); } )*
  { return e1; }
}

Exp boolOp():
{ Exp e1,e2; }
{
 e1 = Expr() ( <GT> e2=Expr() { e1 = new ASTGr(e1,e2); }
                | <LT> e2=Expr() { e1 = new ASTLt(e1,e2); }
                | <GTOEQ> e2=Expr() { e1 = new ASTGrOrEq(e1,e2); }
                | <LTOEQ> e2=Expr() { e1 = new ASTLTOrEq(e1,e2); } )*
  { return e1; }
}


Exp Expr() :
{ Exp e1, e2; }
{
   e1 = Term()
     [<MINUS> e2 = Expr() { e1 = new ASTSub(e1,e2); }
     | <PLUS> e2 = Expr() { e1 = new ASTAdd(e1,e2); } ]
     { return e1; }
}

Exp Term() :
{ Exp e1, e2; }
{
     e1 = Fact()
     [ <DIV> e2 = Term() { e1 = new ASTDiv(e1,e2); }
     | <TIMES> e2 = Term() { e1 = new ASTMult(e1,e2); } ]
     { return e1; }
}

Exp Fact() :
{ Token x; Exp e;}
{
  	x = <Num>
 {
 	return new ASTInt(Integer.parseInt(x.image));
 }
 | <TRUE> { return new ASTBool(true); }
 | <FALSE> { return new ASTBool(false); }
 | <MINUS> e = Expr() { return new ASTSub(new ASTInt(0),e); }
 | <LPAR> e = Expr() <RPAR> { return e; }
}